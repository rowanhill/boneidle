<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Boneidle : Java annotation-driven lazy loading for the indolent">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Boneidle</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/rowanhill/boneidle">View on GitHub</a>

          <h1 id="project_title">Boneidle</h1>
          <h2 id="project_tagline">Java annotation-driven lazy loading for the indolent</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/rowanhill/boneidle/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/rowanhill/boneidle/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>
<a id="what-is-it" class="anchor" href="#what-is-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is it?</h2>

<p>Got a bunch of data you want to load in to your class just once, but don't want to write all those tedious ifs yourself?
Don't worry, boneidle has got you covered with these three easy steps:</p>

<ol>
<li>Write a method to do the loading</li>
<li>Annotate the lazy-loaded getters with <code>@LazyLoadWith</code> (or any other method you want to trigger the loader). Annotate the class to make all methods lazily-loaded by default.</li>
<li>Create your lazy-loading proxy with <code>LazyFactory.proxy()</code>
</li>
</ol>

<h2>
<a id="how-do-i-use-it" class="anchor" href="#how-do-i-use-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>How do I use it?</h2>

<p>Suppose you have a data holder class that looks like:</p>

<div class="highlight highlight-java"><pre><span class="pl-mc"><span class="pl-s">public</span> <span class="pl-mc"><span class="pl-s">class</span> <span class="pl-entc">DataClass</span></span> <span class="pl-mc">{</span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">private</span> <span class="pl-s">int</span> id;</span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">private</span> <span class="pl-s">String</span> name;</span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">private</span> <span class="pl-s">String</span> description;</span></span>
<span class="pl-mc"><span class="pl-mc"></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-c"><span class="pl-pdc">/*</span></span></span></span>
<span class="pl-mc"><span class="pl-mc"><span class="pl-c">     * Constructors that take arguments, or are even inaccessible, are fine</span></span></span>
<span class="pl-mc"><span class="pl-mc"><span class="pl-c">     <span class="pl-pdc">*/</span></span></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">private</span> <span class="pl-enf">DataClass</span>(<span class="pl-s">int</span> <span class="pl-v">id</span>) {</span></span>
<span class="pl-mc"><span class="pl-mc">        <span class="pl-v">this</span><span class="pl-ko">.</span>id <span class="pl-ko">=</span> id;</span></span>
<span class="pl-mc"><span class="pl-mc">    }</span></span>
<span class="pl-mc"><span class="pl-mc"></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-c"><span class="pl-pdc">/*</span></span></span></span>
<span class="pl-mc"><span class="pl-mc"><span class="pl-c">     * Un-annotated methods are left alone, so you can mix lazy and eager </span></span></span>
<span class="pl-mc"><span class="pl-mc"><span class="pl-c">     * loaded data</span></span></span>
<span class="pl-mc"><span class="pl-mc"><span class="pl-c">     <span class="pl-pdc">*/</span></span></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">public</span> <span class="pl-s">int</span> <span class="pl-enf">getId</span>() {</span></span>
<span class="pl-mc"><span class="pl-mc">        <span class="pl-k">return</span> id;</span></span>
<span class="pl-mc"><span class="pl-mc">    }</span></span>
<span class="pl-mc"><span class="pl-mc"></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-c"><span class="pl-pdc">/*</span></span></span></span>
<span class="pl-mc"><span class="pl-mc"><span class="pl-c">     * Declare which method to call in order to load the data backing this </span></span></span>
<span class="pl-mc"><span class="pl-mc"><span class="pl-c">     * method using @LazyLoadWith</span></span></span>
<span class="pl-mc"><span class="pl-mc"><span class="pl-c">     <span class="pl-pdc">*/</span></span></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">@LazyLoadWith</span>(<span class="pl-s1"><span class="pl-pds">"</span>loadData<span class="pl-pds">"</span></span>)</span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">public</span> <span class="pl-s">String</span> <span class="pl-enf">getName</span>() {</span></span>
<span class="pl-mc"><span class="pl-mc">        <span class="pl-k">return</span> name;</span></span>
<span class="pl-mc"><span class="pl-mc">    }</span></span>
<span class="pl-mc"><span class="pl-mc"></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-c"><span class="pl-pdc">/*</span></span></span></span>
<span class="pl-mc"><span class="pl-mc"><span class="pl-c">     * Any method can be annotated; it doesn't have to be a JavaBean getter</span></span></span>
<span class="pl-mc"><span class="pl-mc"><span class="pl-c">     <span class="pl-pdc">*/</span></span></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">@LazyLoadWith</span>(<span class="pl-s1"><span class="pl-pds">"</span>loadData<span class="pl-pds">"</span></span>)</span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">public</span> <span class="pl-s">String</span> <span class="pl-enf">tellMeAboutIt</span>() {</span></span>
<span class="pl-mc"><span class="pl-mc">        <span class="pl-k">return</span> description;</span></span>
<span class="pl-mc"><span class="pl-mc">    }</span></span>
<span class="pl-mc"><span class="pl-mc"></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-c"><span class="pl-pdc">/*</span></span></span></span>
<span class="pl-mc"><span class="pl-mc"><span class="pl-c">     * The loader method can be private, but must have no parameters</span></span></span>
<span class="pl-mc"><span class="pl-mc"><span class="pl-c">     <span class="pl-pdc">*/</span></span></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">private</span> <span class="pl-s">void</span> <span class="pl-enf">loadData</span>() {</span></span>
<span class="pl-mc"><span class="pl-mc">        <span class="pl-c"><span class="pl-pdc">//</span> Do something expensive, like a big calculation or read from an</span></span></span>
<span class="pl-mc"><span class="pl-mc">        <span class="pl-c"><span class="pl-pdc">//</span> external source</span></span></span>
<span class="pl-mc"><span class="pl-mc">    }</span></span>
<span class="pl-mc"><span class="pl-mc"></span>}</span></pre></div>

<p>You could then use an instance of it like so:</p>

<div class="highlight highlight-java"><pre><span class="pl-c"><span class="pl-pdc">//</span> For classes with declared null constructors, the convenience override</span>
<span class="pl-c"><span class="pl-pdc">//</span> LazyFactory.proxy(SimpleClass.class) override can be used. Classes with</span>
<span class="pl-c"><span class="pl-pdc">//</span> constructors that take parameters must pass an original object to </span>
<span class="pl-c"><span class="pl-pdc">//</span> lazy-load, however.</span>
<span class="pl-s">DataClass</span> dataClass <span class="pl-ko">=</span> <span class="pl-s">LazyFactory</span><span class="pl-ko">.</span>proxy(<span class="pl-k">new</span> <span class="pl-s">DataClass</span>(<span class="pl-cn">123</span>));

<span class="pl-c"><span class="pl-pdc">//</span> No lazy loading done here</span>
<span class="pl-s">int</span> id <span class="pl-ko">=</span> dataClass<span class="pl-ko">.</span>getId();

<span class="pl-c"><span class="pl-pdc">//</span> Lazy loading done here (i.e. loadData is called)</span>
<span class="pl-s">String</span> name <span class="pl-ko">=</span> dataClass<span class="pl-ko">.</span>getName();

<span class="pl-c"><span class="pl-pdc">//</span> But no loading done here, as it's already happened</span>
dataClass<span class="pl-ko">.</span>getName();

<span class="pl-c"><span class="pl-pdc">//</span> Or here - boneidle knows both methods share the same loader</span>
<span class="pl-s">String</span> description <span class="pl-ko">=</span> dataClass<span class="pl-ko">.</span>tellMeAboutIt();</pre></div>

<p>If all your methods are loaded by the same method, you can put the <code>@LazyLoadWith</code> annotation on the class. Applying
the <code>@LazyLoadWith</code> annotation to a method on a type annotated at the class level will override the class loader, whilst
applying the <code>@ExcludeFromLazyLoading</code> will prevent any lazy-loader from being called for that method:</p>

<div class="highlight highlight-java"><pre>@LazyLoadWith(<span class="pl-s1"><span class="pl-pds">"</span>loadDataForClass<span class="pl-pds">"</span></span>)
<span class="pl-mc"><span class="pl-mc"><span class="pl-s">class</span> <span class="pl-entc">DataClassWithDefaultLoader</span></span> <span class="pl-mc">{</span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">private</span> <span class="pl-s">int</span> id;</span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">private</span> <span class="pl-s">String</span> name;</span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">private</span> <span class="pl-s">String</span> description;</span></span>
<span class="pl-mc"><span class="pl-mc"></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-c"><span class="pl-pdc">/*</span> This won't be lazy loaded - the method will be invoked as written <span class="pl-pdc">*/</span></span></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">@ExcludeFromLazyLoading</span></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">public</span> <span class="pl-s">int</span> <span class="pl-enf">getId</span>() { <span class="pl-cn">...</span> }</span></span>
<span class="pl-mc"><span class="pl-mc"></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-c"><span class="pl-pdc">/*</span> This will be lazy loaded using the class's default loader <span class="pl-pdc">*/</span></span></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">public</span> <span class="pl-s">String</span> <span class="pl-enf">getName</span>() { <span class="pl-cn">...</span> }</span></span>
<span class="pl-mc"><span class="pl-mc"></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-c"><span class="pl-pdc">/*</span> This will be lazy loaded using the loader specified on the method <span class="pl-pdc">*/</span></span></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">@LazyLoadWith</span>(<span class="pl-s1"><span class="pl-pds">"</span>loadDataForDescription<span class="pl-pds">"</span></span>)</span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">public</span> <span class="pl-s">String</span> <span class="pl-enf">getDescription</span>() { <span class="pl-cn">...</span> }</span></span>
<span class="pl-mc"><span class="pl-mc"></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">private</span> <span class="pl-s">void</span> <span class="pl-enf">loadDataForClass</span>() { <span class="pl-cn">...</span> }</span></span>
<span class="pl-mc"><span class="pl-mc"></span></span>
<span class="pl-mc"><span class="pl-mc">    <span class="pl-s">private</span> <span class="pl-s">void</span> <span class="pl-enf">loadDataForDescription</span>() { <span class="pl-cn">...</span> }</span></span>
<span class="pl-mc"><span class="pl-mc"></span>}</span></pre></div>

<h2>
<a id="whats-the-catch" class="anchor" href="#whats-the-catch" aria-hidden="true"><span class="octicon octicon-link"></span></a>What's the catch?</h2>

<p>Since boneidle is powered by CGLIB proxies, there are one or two restrictions:</p>

<ul>
<li>The annotated class must not be final</li>
<li>Lazy-loaded data must always be retrieved through the annotated methods, even within the annotated class; accessing
the fields directly won't trigger any lazy loading</li>
</ul>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Boneidle maintained by <a href="https://github.com/rowanhill">rowanhill</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
