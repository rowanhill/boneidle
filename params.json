{"name":"Boneidle","tagline":"Java annotation-driven lazy loading for the indolent","body":"## What is it?\r\nGot a bunch of data you want to load in to your class just once, but don't want to write all those tedious ifs yourself?\r\nDon't worry, boneidle has got you covered with these three easy steps:\r\n\r\n1. Write a method to do the loading\r\n2. Annotate the lazy-loaded getters with `@LazyLoadWith` (or any other method you want to trigger the loader). Annotate the class to make all methods lazily-loaded by default.\r\n3. Create your lazy-loading proxy with `LazyFactory.proxy()`\r\n\r\n## How do I use it?\r\nSuppose you have a data holder class that looks like:\r\n\r\n```java\r\npublic class DataClass {\r\n    private int id;\r\n    private String name;\r\n    private String description;\r\n\r\n    /*\r\n     * Constructors that take arguments, or are even inaccessible, are fine\r\n     */\r\n    private DataClass(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    /*\r\n     * Un-annotated methods are left alone, so you can mix lazy and eager \r\n     * loaded data\r\n     */\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    /*\r\n     * Declare which method to call in order to load the data backing this \r\n     * method using @LazyLoadWith\r\n     */\r\n    @LazyLoadWith(\"loadData\")\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /*\r\n     * Any method can be annotated; it doesn't have to be a JavaBean getter\r\n     */\r\n    @LazyLoadWith(\"loadData\")\r\n    public String tellMeAboutIt() {\r\n        return description;\r\n    }\r\n\r\n    /*\r\n     * The loader method can be private, but must have no parameters\r\n     */\r\n    private void loadData() {\r\n        // Do something expensive, like a big calculation or read from an\r\n        // external source\r\n    }\r\n}\r\n```\r\n\r\nYou could then use an instance of it like so:\r\n\r\n```java\r\n// For classes with declared null constructors, the convenience override\r\n// LazyFactory.proxy(SimpleClass.class) override can be used. Classes with\r\n// constructors that take parameters must pass an original object to \r\n// lazy-load, however.\r\nDataClass dataClass = LazyFactory.proxy(new DataClass(123));\r\n\r\n// No lazy loading done here\r\nint id = dataClass.getId();\r\n\r\n// Lazy loading done here (i.e. loadData is called)\r\nString name = dataClass.getName();\r\n\r\n// But no loading done here, as it's already happened\r\ndataClass.getName();\r\n\r\n// Or here - boneidle knows both methods share the same loader\r\nString description = dataClass.tellMeAboutIt();\r\n```\r\n\r\nIf all your methods are loaded by the same method, you can put the `@LazyLoadWith` annotation on the class. Applying\r\nthe `@LazyLoadWith` annotation to a method on a type annotated at the class level will override the class loader, whilst\r\napplying the `@ExcludeFromLazyLoading` will prevent any lazy-loader from being called for that method:\r\n\r\n```java\r\n@LazyLoadWith(\"loadDataForClass\")\r\nclass DataClassWithDefaultLoader {\r\n    private int id;\r\n    private String name;\r\n    private String description;\r\n\r\n    /* This won't be lazy loaded - the method will be invoked as written */\r\n    @ExcludeFromLazyLoading\r\n    public int getId() { ... }\r\n\r\n    /* This will be lazy loaded using the class's default loader */\r\n    public String getName() { ... }\r\n\r\n    /* This will be lazy loaded using the loader specified on the method */\r\n    @LazyLoadWith(\"loadDataForDescription\")\r\n    public String getDescription() { ... }\r\n\r\n    private void loadDataForClass() { ... }\r\n\r\n    private void loadDataForDescription() { ... }\r\n}\r\n```\r\n\r\n## What's the catch?\r\nSince boneidle is powered by CGLIB proxies, there are one or two restrictions:\r\n\r\n* The annotated class must not be final\r\n* Lazy-loaded data must always be retrieved through the annotated methods, even within the annotated class; accessing\r\nthe fields directly won't trigger any lazy loading","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}